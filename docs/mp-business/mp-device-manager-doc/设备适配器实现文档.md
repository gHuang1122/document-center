
## 整个设备项目结构如图

![设备适配器文档.png](./img/设备适配器文档.png)


### 编写 某种设备的adapter 相关步骤

1.首先要了解 adapter 原理图 如下



### 实现原理
#### 1.adapter 编写是为了满足不同的设备使用同一个 dispatch 而设计，编写人员是设备需要接入到 device-manager 服务，整个设备调用大致流程如下图所示：


## commom 项目有三个模块

### common-adapter 主要抽象出主要的为 adapter 、command、descriptor、event 4个文件夹
* adapter 文件夹下有 AbstractAdapter每个新的adapter 定义时必须继承的基类，通过扫描获取继承该类的 adapter基本信息；
```java
    //基类 adapter ,提供给新的 adapter 调用时继承
    // 包含基础的 connect和close 命令
    // AdapterEventListener 基础的监控用于连接、关闭、事件上发的指令回调
    // AdapterStatus 设备状态枚举类

    public abstract class AbstractAdapter {
          private static final String COMMAND_ID_CONNECT = "connect";
          private static final String COMMAND_ID_CLOSE = "close";

          @Setter
          private AdapterEventListener callback;

          @Getter
          private AdapterStatus status;

          @Getter
          @Setter
          private String deviceId;

        ······ 等相关信息，具体实现根据基类 adapter类来编写，子类根据自己具体相关命令实现
        ······ 编写相应的实现方式

       /**
       * 根据 set 方法改变 设备的 状态
       * @param status 状态参数
       */
      public void setStatus(AdapterStatus status) {
        this.status = status;
        if (this.callback != null) {
          this.callback.onAdapterStatusChange(status);
        }
      }

      /**
       * 创建指令
       *
       * @param command       指令标识
       * @param parameterJson 指令参数json,
       * @return 创建的指令
       */
      @Nullable
      public abstract AbstractCommand<?, ?, ?> createCommand(String command, String parameterJson);

      /**
      * 事件上报往上报  报到 dispatch 层，处理后将结果上报到 manager
      */
      public <Event extends AbstractEvent<?>> void emit(Event event) {
        if (this.callback != null) {
          this.callback.onEvent(event);
        }
      }
    /**
    * 指令事件上报
    */
      public <Response extends AbstractCommandResponse, Command extends AbstractCommand<?, Response, ?>> void emit(Command command, Response response) {
        if (this.callback != null) {
          this.callback.onCommandResult(command, response);
        }
      }
    }

* AdapterEventListener 抽象化了 onEvent（Event event） 事件上报方法；onCommandResult(Command command, Response response) 指令上报方法
* AdapterStatus 枚举类各种设备的连接情况
* DeviceConnectFailedException 设备常用基础错误封装 每种错误一般要继承这个方法具体实现可以根据实际子类自写

### common-utils 主要有 response schema 等多个模块
* response 文件夹下存放的是 接口调用的返回封装，
* schema 文件夹下的方法主要用于 编写的 adapter 中的 command 指令 ，event 事件的实体转化为json字符串，提供给 manger 让其给上面业务调用

### device-dispatch-common-protocol 主要有 base constant kafka pojo  service 等多个模块

* base 模块主要存放的是一些基础的返回实体 返回参数已经封装，
* constant 模块主要有些设备的常亮组成 例如设备的类型等 指令类型等
* kafka 模块主要是返回的 异步命令事件推送kafka 消息体 和 事件信息发送到Kafka，
* pojo 为封装好的 request 和 response 模块 主要的包含了请求参和 返回参数 开发时可以详细的查看
* service  模块为主要模块，暴露主要对外接口 有一下多个方法
 -- fetchDeviceInfo 方法 获取设备所有 adapters 信息 查看唯一标识符 modelId
 -- fetchCommandInfo  方法  根据 modelId 获取单个 adapter 的相关信息
 -- createConnect 创建连接方法 链接多个设备 根据参数 CreateAdapterRequest 设置多个设备同时连接并创建到不同的 adapter 每个设备创建一个类型的 adapter 连接
 -- reomoveConnect 批量删除连接 调用 removeConnect 删除连接，DeleteAdapterRequest 包含 deviceId 设备Id ，modelId 为单个adapter的唯一标识, deleteParameterJson 删除或关闭设备连接的参数
 -- runCommand 方法 调用 设备发送指令，根据设备 deviceId 发送相关信息RunCommandRequest 设备发送指令实体， command 指令类型， parameterJson 指令参数， 根据 adapter 中查询的 CommandMessages 某条指令发送信息


#### 开发实例
##### 1. dispach 服务对adapter处理方式
 * 将 开发好的 adapter 上传到 dispatch 服务指定文件夹，
 * dispatch 服务读取相关配置，获取 adapter 服务的相关信息，
 * dispatch 提供相关接口调用 adapter 服务。

##### 2. adapter 技术实现
* 约定在编写每个adapter时，注明每个adapter的基本信息，举例：adapter-camera-hk-xxx,camera 为 adapter 类型， hk 为厂商，后面的xxx可根据版本来确定；
* 在 idea 中创建以上述为名称的项目，去掉启动类等。

###### a.adapter的具体实现。编写主要 adapter 类模块在pom文件中应当引入对应common的依赖，如在adapter-camera-hk-xxx中我们引commom中的两个依赖:
 ```xml
        <dependency>
            <groupId>com.cssc.ljmp.device</groupId>
            <artifactId>common-adapter</artifactId>
            <version>0.1.1</version>
        </dependency>
        <dependency>
            <groupId>com.cssc.ljmp.device</groupId>
            <artifactId>common-utils</artifactId>
            <version>0.1.1</version>
        </dependency>
```

* 在项目中编写的目录下编写相关实现,例如 CameraAdapter

```java

//继承来自common-adapter 中的 AbstractAdapter（必须继承 不然后面包无法扫描到）
public class GateAdapter extends AbstractAdapter {


    /**
   * 创建指令
   * @param command       指令标识，例如：cut 截图指令
   * @param parameterJson 指令参数json,
   * @return 创建的指令
   */
  @Override
  public AbstractCommand<?, ?, ?> createCommand(String command, String parameterJson){
    // 创建一个 抽象的 AbstractCommand 将 CameraAdapter 放入 抽象命令中
    AbstractCommand<?, ?, CameraAdapter> cmd = null;
    // 打印输入，当然可以自己定义
    log.info("====>> into createCommand. deviceId: {}; command：{};  parameterJson：{}", this.getDeviceId(), command, parameterJson);
    switch (command) {
      case Constant.Commands.CONNECT: {
        //command：connect;  parameterJson：{"ip":"172.18.42.174","port":9102}
        cmd = new ConnectCommand();
        break;
      }
      case Constant.Commands.CLOSE: {
        //command：close;  parameterJson：{}
        cmd = new CloseCommand();
        break;
      }
      default:
        log.warn("====>> command error！！！ deviceId: {}; command: {}; parameterJson: {}", this.getDeviceId(), command, parameterJson);
        return null;
    }
    cmd.setAdapter(this);
    cmd.setParameterFromJson(parameterJson);
    return cmd;
  }

  /**
   * 关闭连接
   * @param closeResponse
   * @return
   */
  @Override
  public Mono<Void> onClose(Object closeResponse) {

}

 /**
   * 处理连接后需要进行的操作，如更新status, 开始状态事件上报等等<br/>
   * 注意，需先判断connectResponse是否成功<br/>
   * 连接失败应返回包含<strong>DeviceConnectFailedException</strong>的Mono
   *
   * @param connectResponse 连接指令回执
   * @return Mono
   */
  @Override
  protected Mono<Void> onConnect(Object connectResponse) {

  }

```
* 上面三个方法的主要使用 createCommand 创建命令主要为 所有设备调用时预创建命令
* onClose 为断开命令 后续要优化为 remove  设备的移除 关闭后应该是柔和关闭 记录关闭前 设备基本信息
* onConnect 设备连接指令 维护心跳，维护状态，初始化基本信息
* 上述 状态信息根据状态事件上报到 dispatch , dispatch 根据上报的 status 更新到 nocas 等服务
* 上述 CameraCutPictureCommand 中根据异步请求 将消息返回上报到 dispatch

```java
    // camera 的 CameraDescriptor 必须集成 DeviceDescriptor 同时要将创建的 CameraAdapter 编入
    public class CameraDescriptor extends DeviceDescriptor<CameraAdapter> {

        // 编写 adapter 的唯一标识 modelID 编写adapter 的名称
        @Override
        public DeviceInfo getInfo() {
            val info = new DeviceInfo();
            info.setCategory(DeviceInfo.DEVICE_CATEGORY_CAMERA);
            info.setModelId("device-camera-hk");
            info.setModelName("摄像机设备");
            return info;

        }

        // 获取设备命令信息 获取所有相关命令 将其放入set 集合
        @Override
        public Set<CommandInfo> getCommands() {
            return Stream
                    .of(new CameraConnectCommand(), new CameraCutPictureCommand())
                    .map(AbstractCommand::generateCommandInfo)
                    .collect(Collectors.toSet());
        }

        // 将所有 event 包下的文件放入 set 集合
        @Override
        public Set<EventInfo> getEvents() {
            return Stream
                    .of(new CameraStatusEvent())
                    .map(AbstractEvent::generateEventInfo)
                    .collect(Collectors.toSet());
        }

        // 根据设备唯一标识 deviceId 创建 createAdapter
        @Override
        public CameraAdapter createAdapter(String deviceId) {
            val adapter = new CameraAdapter();
            adapter.setDeviceId(deviceId);
            return adapter;
        }
    }
```

* command 包下文件
-- CameraConnectCommand 必须集成 AbstractCommand 并自己定义 链接参数 Parameter ，返回参数 Response 自己定义 可以在自己的业务里面使用即可解析 status 为必须返回字段 msg 字段内容可以自己定义
-- run 方法自自己编写先关
```java
// CameraConnectCommand 链接指令类
public class CameraConnectCommand  extends AbstractCommand<CameraConnectCommand.Parameter,CameraConnectCommand.Response, CameraAdapter> {
    // 定义是否是异步方法
    @Override
    public Boolean isAsynchronous() {
        return true;
    }
    // 命令类型
    @Override
    public String command() {
        return Constant.Commands.CONNECT;
    }
    // kafka 定义 topic 有就定义 没有就不定义
    @Override
    public String kafkaTopic() {
        return null;
    }
    // 错误信息
    @Override
    protected Set<ErrorInfo> errorInfo() {
        return Stream.of(new ErrorInfo(01, "连接失败")).collect(Collectors.toSet());
    }
    // 参数信息
    @Override
    protected Class<Parameter> parameterClass() {
        return Parameter.class;
    }
    // 自定义参数信息
    @Override
    protected Class<Response> responseClass() {
        return Response.class;
    }

    // 命令基本信息描述
    @Override
    protected String description() {
        return "连接指令";
    }

    // 具体实现方法
    @Override
    public Mono<Response> run() {
        Parameter parameter = this.parameter;
        this.adapter.setBaseUrl("");
        Runnable runnable = new Runnable() {
            HttpRequest request = new HttpRequest("").post();
            @Override
            public void run() {
                HttpRequest request = new HttpRequest("url").post();
                val res = new Response();
                try {
                    request.jsonBody(Collections.singletonMap("cameraId", ""));
                    request.responseJson(Response.class).map(response -> {
                        // 状态信息上报
                        adapter.setCameraStatus(response);
                        return null;
                    });
                } catch (JsonProcessingException e) {
                    e.printStackTrace();
                }

                System.out.println("定时任务线程执行中......");
            }
        };
        // 此处用到多线程定时调用
        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
        service.scheduleWithFixedDelay(runnable, 0, 15000, TimeUnit.MILLISECONDS);
        // 返回实体要自己定义
        return null;
    }


    // 定义 参数 必须继承 AbstractCommandParameter 不然系统无法识别并转化为 参数对象
    @Data
    @EqualsAndHashCode(callSuper = true)
    public static class Parameter extends AbstractCommandParameter {

        @Schema(description = "设备地址", required = true)
        private String ip;

        @Schema(description = "设备端口", required = true)
        @Min(0)
        @Max(65535)
        private Integer port;

        @Schema(description = "路径后地址", required = true)
        private String followUrl;

//       lianjie /flv/probe?address=rtsp://admin:vomont.video@172.18.42.111
        @Schema(description = "参数", required = true)
        private String  param;


    }

    // 返回定义
    @Data
    @EqualsAndHashCode(callSuper = true)
    public static class Response extends AbstractCommandResponse {
      // 返回设备状态定义
      private Integer deviceStatus;
      // 自定义返回描述信息
      private String msg；
    }
}
```

* constant 包 定义基本常用信息 如kafka 基本的topic 等信息，设备连接指令等基本信息

```java

    /**
     * @author ：hzp.
     * @ Date       ：Created in  2021/5/14
     * @ Description：命令常量
     * @ Modified By：
     * @ Version:     0.0.1
     */
    public class Constant {

        // 自定义剪切命令的 topic 返回到
        public static final String KAFKA_TOPIC_CUT_PICTURE= "camera-hk-cut-picture";



        public static class Events {
            public static final String STATUS_UPDATE = "status";
        }

        public static class Commands {
            /**
             * 连接指令
             */
            public static final String CONNECT = "connect";

            /**
             * 关闭指令
             */
            public static final String CUT_PICTURE="cut-picture";

            /**
             * 异步指令
             */
            public static final String ASYNC = "async";
        }
    }

```
* event 模块 根据具体设备上报信息
 -- 目前camera-adapter 自发请求摄像机然后自己上报单个摄像机的参数
 ```java
  /**
 * @author ：hzp.
 * @ Date       ：Created in  2021/5/17
 * @ Description：摄像头状态返回
 * @ Modified By：
 * @ Version:     0.0.1
 */
public class CameraStatusEvent extends AbstractEvent<CameraStatusEvent.Message> {

    // 消息messsage 对象
    @Override
    protected Class<Message> messageClass() {
        return Message.class;
    }

    // 定义时间类型
    @Override
    public String event() {
        return Constant.Events.STATUS_UPDATE;
    }

    // 是否 kafka topic  返回
    @Override
    public String kafkaTopic() {
        return null;
    }

    // 消息体必须集成 AbstractEventMessage
    @ToString
    public static class Message extends AbstractEventMessage {

        @Schema(description = "设备状态", required = true)
        @Getter
        private final AdapterStatus status;


        public Message(AdapterStatus status) {
            super();
            this.status = status;
        }
    }
}
 ```

### 1.连接指令：connect
* 请求URL：http://localhost:8081/deviceDispatch
* 请求方式：POST
* 请求JSON格式消息体:

```json
    [
      {
          "deviceId": "qwe12qwe3456789qeq",
          "deviceModelId": "device-camera-hk",
          "param":"{\"ip\":\"172.18.42.174\",\"port\":9102,\"followUrl\":\"/flv/probe\",\"param\":\"address=rtsp://admin:vomont.video@172.18.42.111\"}"
      }
    ]
```


# 开发案例基本类如下过成

## device-adapter-gate (闸机设备Adapter)

* 支持闸机设备的连接、关闭、入闸、出闸、告警反馈、工作模式设置指令的操作。

## 一、项目结构说明

**com.cssc.ljmp.device.adapter.gate.joydata.v1**

//com.cssc.ljmp.device.adapter.${设备category}.${设备厂商}.${设备型号}

- **adapter**     <!--适配器包-->

  * GateAdapter.java     **//闸机适配器，提供上层Dispatcher服务对适配器设备通用创建指令，连接，关闭的方法。**

    * ```java
      public AbstractCommand<?, ?, ?> createCommand(String command, String parameterJson);
      protected Mono<Void> onConnect(Object connectResponse);
      public Mono<Void> onClose(Object closeResponse);
      ```

  * GateDesciptor.java    **//闸机设备信息，提供上层Dispatcher服务通用获取适配器设备基础信息，指令信息，事件信息，根据设备ID创建Adapter的方法。**

    ```java
      public abstract DeviceInfo getInfo();
      public abstract Set<CommandInfo> getCommands();
      public abstract Set<EventInfo> getEvents();
      public abstract Adapter createAdapter(String deviceId);
      ```

 **command**   <!--命令封装包-->

  * AlarmSignalCommand.java  //报警信号反馈指令操作
  * CloseCommand.java.java     //关闭连接指令操作
  * ConnectCommand.java        //连接指令操作
  * InGateCommand.java          //入闸指令操作
  * OutGateCommand.java       //出闸指令操作
  * WorkModeCommand.java  //工作模式指令操作

   - **constant**     <!--常量封装包-->

        * Constant.java     // Kafka Topic和指令事件，报文编号常量

   - **event**           <!--事件处理包-->

        * HeartBeatUpdateEvent.java    //心跳事件上报
        * StatusUpdateEvent.java           //状态事件上报

   - **handler**       <!--处理器包-->

        * RequestCommandHandler.java    //请求指令报文处理
        * ResponseMessageHandler.java    //响应报文处理

   - **mode**          <!--实体封装包-->

        * GateResult.java             //闸机入闸/出闸/报警/工作模式授权结果封装
        * HeartResult.java           //心跳结果封装
        * MessageFormat.java   //消息报文结构体
        * TcpResult.java              //tcp结果接口

   - **utils**             <!--工具类包-->

        - NettyByteAndStringUtils.java     //Netty字节，字符串类型转换
        - PushThreadPools.java                 //线程池工具类
        - TypeConvert.java                          //字节、整数、长整数等数据类型之间的拆分和转换。

## 二、指令操作

> 启动Dispatch服务，发送请求指令进行测试。

### 1.连接指令：connect
* 请求URL：http://localhost:8081/deviceDispatch
* 请求方式：POST
* 请求JSON格式消息体:

```json
    [
      {
          "deviceId": "123456789",
          "deviceModelId": "device-gate",
          "connectParameterJson":"{\"ip\":\"172.18.42.174\",\"port\":9102}"
      }
    ]
```

### 2.关闭指令：close

* 请求URL：http://localhost:8081/deviceDispatch/disconnect
* 请求方式：POST
* 请求JSON格式消息体:

```json
    [
      {
        "deviceId": "123456789",
        "deviceModelId": "device-gate",
        "deleteParameterJson": ""
      }
    ]
```

### 3.入闸指令：inGate

* 请求URL：http://localhost:8081/deviceDispatch/123456789
* 请求方式：POST
* 请求JSON格式消息体:

```json
    {
        "command": "inGate",
        "parameterJson": ""
    }    
```

### 4.出闸指令：outGate

* 请求URL：http://localhost:8081/deviceDispatch/123456789
* 请求方式：POST
* 请求JSON格式消息体:

```json
{
        "command": "outGate",
        "parameterJson": ""
    }
```

### 5.工作模式设置指令：setWorkMode

```json
* 请求URL：http://localhost:8081/deviceDispatch/123456789
* 请求方式：POST
* 请求JSON格式消息体:
    {
        "command": "setWorkMode",
        "parameterJson":"{\"workMode\":0}"
    }
```

### 6.报警信号反馈指令：alarmSignalFeedback

```json
* 请求URL：http://localhost:8081/deviceDispatch/123456789
* 请求方式：POST
* 请求JSON格式消息体:
    {
        "command": "alarmSignalFeedback",
        "parameterJson":"{\"alarmType\":0}"
    }
```
